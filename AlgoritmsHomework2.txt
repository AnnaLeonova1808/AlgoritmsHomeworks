1.Как оценивается эффективность алгоритма?
Эффективность алгоритма оценивается 
1)Фактор времени: время измеряется путем подсчета количества ключевых операций. Временная сложность - количество операций.Neme Complexity
2) Фактор пространства: пространство измеряется путем подсчета максимального объема памяти, требуемого алгоритмом. Space Complexity

2.Что учитывается при асимптотическом анализе?
Оцениваем производительность алгоритма с точки зрения размера входных данных по времени выполнения и используемой памяти.
Асимптомический аналих сводится : На сколько возростает сложность алгоритма в зависимости от входных данных.
3.Перечислите основные правила асимптотического анализа
Важные правила асимптотического анализа:

O(k*f) = O(f) – постоянный множитель k (константа) отбрасывается, поскольку с ростом объема данных, его смысл теряется, например:
O(9,1n) = O(n)

O(f*g) = O(f)*O(g) – оценка сложности произведения двух функций равна произведению их сложностей, например:
O(5n*n) = O(5n)*O(n) = O(n)*O(n) = O(n*n) = O(n2)

O(f/g)=O(f)/O(g) – оценка сложности частного двух функций равна частному их сложностей, например:
O(5n/n) = O(5n)/O(n) = O(n)/O(n) = O(n/n) = O(1)

O(f+g) равна доминанте O(f) и O(g) – оценка сложности суммы функций определяется как оценка сложности доминанты первого и второго слагаемых, например:
O(n5+n10) = O(n10)

4.Какие порядки роста асимтотических функций знаете?
Основные оценки роста, встречающиеся в асимптотическом анализе:

Ο (О-большое) – верхняя асимптотическая оценка роста временной функции;
Ω (Омега) – нижняя асимптотическая оценка роста временной функции;
Θ (Тета) – нижняя и верхняя асимптотические оценки роста временной функции.

5.Оцените сложность по времени и памяти
void method(int n) {
        for (int i = 0; i < n / 2; i++) {
            for (int j = 1; j + n / 2 <= n; j++) {
                for (int k = 1; k <= n; k = k * 2) {
                    System.out.println("I am expert!");
                }
            }
        }
    }

//Первый цикл for выполняется n/2 раз.

Второй цикл for выполняется (n - n/2) = n/2 раз, так как значение j увеличивается от 1 до (n/2) + (n/2) = n.

Третий цикл for выполняется log(n) раз, так как значение k удваивается на каждой итерации до достижения или превышения n.

Таким образом, общая сложность времени будет O((n/2) * (n/2) * log(n)) = O((n^2/4) * log(n)) = O((n^2) * log(n)).

Сложность по памяти будет константной и составлять O(1).


6.Оцените сложность по времени и памяти
void method2(int n) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j = j + i) {
                System.out.println("I am expert!");
            }
        }
    }

//1) for (int i = 1; i <= n; i++) выполняется n раз.

2) for (int j = 1; j <= n; j = j + i)  выполняется n раз, но в каждой итерации шаг увеличивается на i.

Ощее количество итераций второй петли можно оценить:

1 + 2 + 3 + ... + n-1 + n

Сумма такой арифметической прогрессии равна (n * (n + 1)) / 2.

Общая сложность по времени этого метода составляет O(n^2), так как количество итераций вложенной петли растет квадратично с увеличением n.

Сложность по памяти в этом методе не зависит от размера входного параметра n и остается константной, так как мы не используем дополнительные структуры данных, которые зависят от n.

7.Оцените сложность по времени и памяти
void method3(int a, int b) { // примечание a > 0 и b > 0
        while (a != b) {
            if (a > b) {
                a = a - b;
            } else {
                b = b - a;
            }
        }
    }

//В этом методе у нас есть цикл while, который выполняется до тех пор, пока a и b не станут равными.

Если a > b, то выполняется операция a = a - b, которая занимает постоянное время.

Если b > a, то выполняется операция b = b - a, которая также занимает постоянное время.

Количество итераций цикла while зависит от разницы между a и b.

Сложность по времени этого метода может быть оценена как O(max(a, b))

Сложность по памяти в этом методе остается константной, так как мы не используем дополнительные структуры данных, которые зависят от a и b.
